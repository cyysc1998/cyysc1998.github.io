<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Knapsack problem</title>
    <link href="/2020/05/18/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2020/05/18/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>记录背包问题的学习过程与解题思路，便于复习</p><span id="more"></span><p><strong>参考</strong></p><ol><li><a href="https://github.com/tianyicui/pack">Tianyi Cui 背包问题九讲</a></li><li><a href="https://www.bilibili.com/video/BV1qt411Z7nE?from=search&seid=11657026350374284334">yxc大佬视频讲解</a></li><li><a href="https://www.acwing.com/problem/">博客中代码测试网站——Acwing</a></li></ol><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><ul><li><p><strong>题目描述：</strong>有$N$件物品和容量为$V$的背包，每件物品的重量为$w_i$, 体积为$v_i$,每件物品仅可使用一次。求不超过背包容量的情况下，背包中物品总重量的最大值。</p></li><li><p><strong>基本思路：</strong>定义子状态：在放到第$i$个物体时，容量为$j$时，背包中物品总重量最大值为$f[i][j]$。对于第$i$个物品，有选择与不选择两种情况。若不选择第$i$个物品，则$f[i][j]$重量与$f[i-1][j]$相等，即该重量等于将前$i-1$个物品放入容量为$j$的背包的总重量。若选择第$i$个物品，则重量为$f[i-1][j-v_i] + w_i$,即将前$i-1$个物品放入容量为$j-v_i$的背包的总重量加上$w_i$。综上可得状态转移方程：</p><p>$$f[i, j]&#x3D;max(f[i-1,j],f[i-1,j-v_i]+w_i)$$</p><ul><li><p>时间复杂度$O(NV)$，空间复杂度$O(NV)$</p></li><li><p>代码实现(<a href="https://www.acwing.com/problem/content/2/">题目链接</a>)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i ++) <br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i ++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j ++) &#123;<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i])<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j], f[i<span class="hljs-number">-1</span>][j-v[i]] + w[i]);<br>            <span class="hljs-keyword">else</span><br>                f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[N][V] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>空间复杂度的优化</strong></p><p>在上面的状态转移方程中，注意到$f[i][0..V]$的状态仅与$f[i-1][0..V]$的状态有关，那么能仅使用一个一维数组表示容量为$j$时的解吗？由于外层循环是$1-N$，那么在计算$f[i][j]$时需要$f[i-1][j-v_i]$的状态，如果直接去掉数组的第一维，就相当于在用$f[i][j-v_i]$的状态更新$f[i][j]$，状态转移错误。解决的办法是去掉数组的第一维的同时倒着遍历内层循环，原理是$v_i&gt;0$，故$j&gt;j-v_i$，因此再倒序遍历中计算$f[j]$时，$f[j-v_i]$保留的是$f[i-1,j-v_i]$的值。</p><ul><li><p>代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i ++) <br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i ++) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = V; j &gt;= v[i]; j --) <br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j-v[i]] + w[i]);<br>        <br>    cout &lt;&lt; f[V] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意：实现中，由于$f$数组初始化为0，故直接在内层循环添加判断条件$j \geq v[i]$即可。</p></li></ul></li><li><p><strong>初始化问题</strong></p><p>在背包问题中，有求出“装满背包条件下的最大重量”与“不超过背包容积的最大重量”两种问法。可以通过数组的初始化巧妙地解决这个问题。</p><ul><li>$f[0]&#x3D;0, f[1..V]&#x3D;-∞$时，求出的为“恰好装满”情况下的解</li><li>$f[0]&#x3D;0, f[1..V]&#x3D;0$时，求出的为“不超过容积”情况下的解</li></ul><p>可以理解为，由于动态规划是将一个状态转化为子状态从而解决问题，从装满的角度看，$f[0]$是在什么也不装的条件下唯一满足条件的解（否则空间不为0，不可能装满），因此将$f[1..V]$定义为负无穷，保证最大值一定是从$f[0]$转化而来。</p><p>对于“不超过”情况，$f[V]$一定最大，假设具有最优容量的$f[k]$最大,由于$f[V]$与$f[k]$有相同的状态转移过程，故两者相等（可以理解成偏移）。</p><blockquote><p>在上面代码中，数组g被默认全部初始化为0，因此$f[V]$为不超过容量V下的最大重量即为答案。若仅初始化$f[0]&#x3D;0$则需遍历$f$数组，求出最大值。</p></blockquote></li></ul><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><ul><li><p><strong>题目描述：</strong>有$N$件物品和容量为$V$的背包，每件物品的重量为$w_i$, 体积为$v_i$,每件物品仅可使用无限次。求不超过背包容量的情况下，背包中物品总重量的最大值。</p></li><li><p><strong>思路：</strong>由于背包容量最大为$V$，故每样物品最多可使用$V&#x2F;v_i$次。所以可在01背包问题的基础上，添加一次循环，寻找前$i$个物品一定容量下物品$i$获得最大价值的放置数量，状态转移方程可改为：</p><p>$$f[i, j]&#x3D;max(f[i-1,j-kv_i]+kw_i)(0\leq kv_i\leq V)$$</p><ul><li>该算法时间复杂度为$O(NV\sum V&#x2F;v_i)$</li><li>优化：对于那些$v_i \geq v_j， w_i \leq w_j$的物品$i$可以在预处理时直接去除。</li></ul></li><li><p><strong>与01背包关系：</strong></p><ul><li>每样物品最多可使用$V&#x2F;v_i$次，故可以将无限次数使用的物品$i$换为$V&#x2F;v_i$个物品$i$，所有物体或者选或者不选，从而将其转化为01背包问题。</li><li>更高效的转化方式可以利用二进制的思想，将物品$i$转化为体积为$v_i2^k$,重量为$w_i2^k$个物体，其中$0\leq v_i*2^k\leq V$，故每件物品被分为$O(logV&#x2F;v_i)$个。</li></ul></li><li><p><strong>算法实现：</strong></p><ul><li><p>$f[i, j] &#x3D; max(f[i-1, j], f[i-1, j-v_i]+w_i+…+f[i-1,j-kv_i])+kw_i)$</p><p>$f[i, j-v_i] &#x3D; max(f[i-1, j-v_i],f[i-1, j-2v_i]+w_i+…+f[i-1,j-kv_i])+kw_i)$</p><p>将$f[i,j-v_i]+w_i$代入$f[i,j]$表达式。有$f[i, j] &#x3D; max(f[i-1, j],f[i][j-v_i]+w_i)$</p></li><li><p>为实现上面的递推公式，将01背包问题中内层循环$j$顺序颠倒即可，关键部分如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i ++) <br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[i]; j &lt;= V; j ++) &#123;<br>  f[j] = <span class="hljs-built_in">max</span>(f[j], f[j-v[i]] + w[i]);<br></code></pre></td></tr></table></figure></li><li><p>状态转移方程：$f[i, j]&#x3D;max(f[i-1,j],f[i,j-v_i])+w_i$</p></li><li><p>理解：在01背包中$f[i, j]&#x3D;max(f[i-1,j],f[i-1,j-v_i])+w_i$，即前$i$个物体的状态由前$i-1$个物品的状态决定，所以要逆序遍历保留第$i-1$个物品时的状态。而在完全背包问题中，每个物品可以使用无限次，故$f[i, j]&#x3D;max(f[i-1,j],f[i,j-v_i])+w_i$，前$i$个物品在容量$j$时的状态与前$i$个物品在容量为$j-v_i$时的状态有关，这里$f[i,j-v_i]$中可能已经选择若干个物品$i$，也就是01背包中计算$f[i, j]$需要一个没有计算物品$i$的子结果$f[i-1,j-w_i]$，而完全背包中需要一个已经计算物品$i$的子结果$f[i ,j-w_i]$，而顺序遍历即可保证计算计算$f[i, j]$前，$f[i,j-w_i]$已经被计算。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>常用模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>背包问题</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT 1143 Lowest Common Ancestor</title>
    <link href="/2020/05/14/PAT-1143-Lowest-Common-Ancestor/"/>
    <url>/2020/05/14/PAT-1143-Lowest-Common-Ancestor/</url>
    
    <content type="html"><![CDATA[<h2 id="PAT-1143-Lowest-Common-Ancestor"><a href="#PAT-1143-Lowest-Common-Ancestor" class="headerlink" title="PAT 1143 Lowest Common Ancestor"></a>PAT 1143 Lowest Common Ancestor</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805343727501312">1143 Lowest Common Ancestor</a></p><span id="more"></span><ul><li><p>输入输出：</p><ol><li>输入：BST， 先序遍历，待查询节点对</li><li>输出：最低公共祖先</li></ol></li><li><p>思路：</p><ol><li><p>重建二叉树（较慢）：</p><ul><li>根据先序遍历、中序遍历重建二叉树（由于是BST， 所以可以通过先序遍历排序得到中序遍历）</li><li>判断所给节点对是否存在（判断是否在给定遍历序列中即可），若至少一个不存在，输出对应结果，若均存在，使用LCA算法得到最低公共祖先，根据情况判断输出格式</li><li>LCA思路——<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2/">LeetCode 236. Lowest Common Ancestor of a Binary Tree</a></li></ul></li><li><p><a href="https://www.liuchuo.net/archives/4616">https://www.liuchuo.net/archives/4616</a></p></li></ol></li><li><p>注意：</p><ol><li>建树时可以用哈希表储存中序遍历中每个节点的位置，减少时间复杂度</li><li>测试点2中节点个数为1，需注意</li></ol></li><li><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> inorder[N], pre[N];<br><span class="hljs-type">int</span> l[N], r[N];<br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pos;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> blank = <span class="hljs-number">0x7f7f7f7f</span>;<br><span class="hljs-type">int</span> n, m, ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> root = pre[pl];<br>    <span class="hljs-type">int</span> k = pos[root];<br>    <span class="hljs-keyword">if</span>(il &lt; k) l[root] = <span class="hljs-built_in">build</span>(il, k<span class="hljs-number">-1</span>, pl+<span class="hljs-number">1</span>, pl+<span class="hljs-number">1</span> + (k<span class="hljs-number">-1</span>-il));<br>    <span class="hljs-keyword">if</span>(k &lt; ir) r[root] = <span class="hljs-built_in">build</span>(k+<span class="hljs-number">1</span>, ir, pl+<span class="hljs-number">1</span> + (k<span class="hljs-number">-1</span>-il) + <span class="hljs-number">1</span>, pr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == blank)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> lson = <span class="hljs-built_in">dfs</span>(l[root], p, q);<br>    <span class="hljs-type">bool</span> rson = <span class="hljs-built_in">dfs</span>(r[root], p, q);<br>    <span class="hljs-keyword">if</span>(lson &amp;&amp; rson || ((root == p || root == q) &amp;&amp; (lson || rson)))<br>        ans = root;<br>    <br>    <span class="hljs-keyword">return</span> lson || rson || (root == p || root == q);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(l, <span class="hljs-number">0x7f</span>, <span class="hljs-keyword">sizeof</span> l);<br>    <span class="hljs-built_in">memset</span>(r, <span class="hljs-number">0x7f</span>, <span class="hljs-keyword">sizeof</span> r);<br>    cin &gt;&gt; m &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>        cin &gt;&gt; pre[i];<br>        inorder[i] = pre[i];<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(inorder + <span class="hljs-number">1</span>, inorder + n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        pos[inorder[i]] = i;<br>    <br>    <span class="hljs-type">int</span> root = <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, n);<br>   <br>    <span class="hljs-keyword">while</span>( m-- ) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span>(pos[a] == <span class="hljs-number">0</span> &amp;&amp; pos[b] == <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: %d and %d are not found.\n&quot;</span>, a, b);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pos[a] == <span class="hljs-number">0</span> &amp;&amp; pos[b] != <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: %d is not found.\n&quot;</span>, a);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pos[a] != <span class="hljs-number">0</span> &amp;&amp; pos[b] == <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: %d is not found.\n&quot;</span>, b);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">dfs</span>(root, a, b);<br>            <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>                ans = inorder[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(ans == a)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d is an ancestor of %d.\n&quot;</span>, a, b);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ans == b)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d is an ancestor of %d.\n&quot;</span>, b, a);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LCA of %d and %d is %d.\n&quot;</span>, a, b, ans);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树的重建</tag>
      
      <tag>LCA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构造二叉树(给定遍历序列)</title>
    <link href="/2020/05/08/%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%BB%99%E5%AE%9A%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <url>/2020/05/08/%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%BB%99%E5%AE%9A%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="构造二叉树"><a href="#构造二叉树" class="headerlink" title="构造二叉树"></a>构造二叉树</h2><p>如何根据给定的两个遍历序列重构二叉树？</p><span id="more"></span><blockquote><p>常见的二叉树遍历方法有先序遍历、中序遍历、后序遍历、层序遍历，给定其中两种遍历方法，有些可以构建唯一的二叉树，有些无法确定唯一的二叉树</p></blockquote><ul><li><p><strong>先序遍历 + 中序遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * vector中存先序遍历、中序遍历序列</span><br><span class="hljs-comment"> * 使用哈希表储存树</span><br><span class="hljs-comment"> * 可以额外开一个哈希表记录中序遍历中根的位置，避免内层k的遍历</span><br><span class="hljs-comment">*/</span><br>vector&lt;<span class="hljs-type">int</span>&gt; pre, inorder<br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; l, r;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> root = pre[pl];<br>    <span class="hljs-type">int</span> k = il;<br>    <span class="hljs-keyword">while</span>(inorder[k] != root &amp;&amp; k &lt;= ir) <br>        k++;<br>    <span class="hljs-keyword">if</span>(k &gt; ir)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(il &lt; k) l[root] = <span class="hljs-built_in">build</span>(il, k<span class="hljs-number">-1</span>, pl+<span class="hljs-number">1</span>, pl+<span class="hljs-number">1</span>+(k<span class="hljs-number">-1</span>-il));<br>    <span class="hljs-keyword">if</span>(k &lt; ir) r[root] = <span class="hljs-built_in">build</span>(k+<span class="hljs-number">1</span>, ir, pl+<span class="hljs-number">1</span>+(k<span class="hljs-number">-1</span>-il)+<span class="hljs-number">1</span>, pr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>中序遍历 + 后序遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * vector中存中序遍历、后序遍历序列</span><br><span class="hljs-comment"> * 使用哈希表储存树</span><br><span class="hljs-comment"> * 额外开一个哈希表记录中序遍历中根的位置，避免内层k的遍历</span><br><span class="hljs-comment">*/</span><br>vector&lt;<span class="hljs-type">int</span>&gt; inorder， post<br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; root_pos;<br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; l, r;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> root = post[pr];<br>    <span class="hljs-type">int</span> k = root_pos[root];<br>    <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(il &lt; k) l[root] = <span class="hljs-built_in">build</span>(il, k<span class="hljs-number">-1</span>, pl, pl+(k<span class="hljs-number">-1</span>-il));<br>    <span class="hljs-keyword">if</span>(k &lt; ir) r[root] = <span class="hljs-built_in">build</span>(k+<span class="hljs-number">1</span>, ir, pl+(k<span class="hljs-number">-1</span>-il)+<span class="hljs-number">1</span>, pr<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>先序遍历 + 后序遍历</strong></p><p>由于无法确定左右子树的分割点，无法确定是否能构造出子树或者构造唯一的子树，一个方法是可以爆搜所有可能的解，下面是一个示例题目</p><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805353470869504">PAT 1119 Pre- and Post-order Traversals</a></p></li><li><p><strong>层序遍历 + 中序遍历</strong></p><ul><li><p>层序遍历具有下面两个特征：</p><ol><li>一个子树的根节点一定出现在其子节点前</li><li>在整个二叉树的层序遍历中 ，某一子树的层序遍历序列中各节点相互顺序与整体层序遍历相同</li></ol></li><li><p>过程如下：</p><img src="https://cyysc1998.github.io/images/inorder_sequence.png" width="80%" height="80%"/></li><li><p>下面是一个示例程序：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 1. 根据层序遍历得到子树的根</span><br><span class="hljs-comment"> * 2. 在中序遍历中找到根，得到左右子树的分界点</span><br><span class="hljs-comment"> * 3. 将中序遍历分界点左侧、右侧节点依次按顺序存入左、右子树中序遍历中</span><br><span class="hljs-comment"> * 4. 将层序遍历中的节点分别加入左、右子树层序遍历中</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; l, r;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; seq)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(inorder.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> root = seq.<span class="hljs-built_in">front</span>();<br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(inorder[k] != root &amp;&amp; k &lt; inorder.<span class="hljs-built_in">size</span>()) <br>k++;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; l_in, l_seq, r_in, r_seq;<br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; tb;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;k; i++) &#123;<br>l_in.<span class="hljs-built_in">push_back</span>(inorder[i]);<br>tb[inorder[i]] = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k+<span class="hljs-number">1</span>; i&lt;inorder.<span class="hljs-built_in">size</span>(); i++) &#123;<br>r_in.<span class="hljs-built_in">push_back</span>(inorder[i]);<br>tb[inorder[i]] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;seq.<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-keyword">if</span>(tb[seq[i]] == <span class="hljs-number">-1</span>)<br>l_seq.<span class="hljs-built_in">push_back</span>(seq[i]);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tb[seq[i]] == <span class="hljs-number">1</span>)<br>r_seq.<span class="hljs-built_in">push_back</span>(seq[i]);<br>&#125;<br><br><span class="hljs-keyword">if</span>(!l_in.<span class="hljs-built_in">empty</span>()) l[root] = <span class="hljs-built_in">build</span>(l_in, l_seq);<br><span class="hljs-keyword">if</span>(!r_in.<span class="hljs-built_in">empty</span>()) r[root] = <span class="hljs-built_in">build</span>(r_in, r_seq);<br><br><span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    cout &lt;&lt; u &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">if</span>(l[u]) <span class="hljs-built_in">preorderTraversal</span>(l[u]);<br><span class="hljs-keyword">if</span>(r[u]) <span class="hljs-built_in">preorderTraversal</span>(r[u]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; inorder, seq;<br><span class="hljs-type">int</span> n, t;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>cin &gt;&gt; t;<br>inorder.<span class="hljs-built_in">push_back</span>(t);<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>cin &gt;&gt; t;<br>seq.<span class="hljs-built_in">push_back</span>(t);<br>&#125;<br><br><span class="hljs-type">int</span> root = <span class="hljs-built_in">build</span>(inorder, seq);<br><span class="hljs-built_in">preorderTraversal</span>(root);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>常用模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>Inorder traversal</tag>
      
      <tag>Preorder traversal</tag>
      
      <tag>Postorder traversal</tag>
      
      <tag>Sequence traversal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 617. Merge Two Binary Trees</title>
    <link href="/2020/05/07/LeetCode-617-Merge-Two-Binary-Trees/"/>
    <url>/2020/05/07/LeetCode-617-Merge-Two-Binary-Trees/</url>
    
    <content type="html"><![CDATA[<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><p>题目链接：<a href="https://leetcode.com/problems/merge-two-binary-trees/">LeetCode 617. Merge Two Binary Trees</a></p><span id="more"></span><blockquote><p>题目中不要求保留原二叉树的结构，因此直接在t1或t2上修改即可</p></blockquote><ul><li><p>一个简单的思路是直接先序遍历两棵树，将相同位置节点的权值加到其中一棵树上，同时合并形状</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(t1 == <span class="hljs-literal">nullptr</span>) <br>            <span class="hljs-keyword">return</span> t2;<br>        <span class="hljs-keyword">if</span>(t2 == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> t1;<br>        t1-&gt;val += t2-&gt;val;<br>        t1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);<br>        t1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);<br>        <span class="hljs-keyword">return</span> t1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>也可以迭代解决这个问题，使用一个储存两棵树对应位置元素对的栈，每次取出栈顶元素进行合并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!t1) <span class="hljs-keyword">return</span> t2;<br>        stack&lt;pair&lt;TreeNode*, TreeNode*&gt;&gt; sk;<br>        sk.<span class="hljs-built_in">push</span>(&#123;t1, t2&#125;);<br>        <span class="hljs-keyword">while</span>(!sk.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> p = sk.<span class="hljs-built_in">top</span>();<br>            sk.<span class="hljs-built_in">pop</span>();<br>            TreeNode* u1 = p.first, * u2 = p.second;<br>            <br>            <span class="hljs-keyword">if</span>(!u2)<br>                <span class="hljs-keyword">continue</span>;<br><br>            u1-&gt;val += u2-&gt;val;   <br>            <br>            <span class="hljs-keyword">if</span>(!u1-&gt;left)<br>                u1-&gt;left = u2-&gt;left;<br>            <span class="hljs-keyword">else</span><br>                sk.<span class="hljs-built_in">push</span>(&#123;u1-&gt;left, u2-&gt;left&#125;);<br>            <span class="hljs-keyword">if</span>(!u1-&gt;right)<br>                u1-&gt;right = u2-&gt;right;<br>            <span class="hljs-keyword">else</span><br>                sk.<span class="hljs-built_in">push</span>(&#123;u1-&gt;right, u2-&gt;right&#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> t1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>Easy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 226. Invert Binary Tree</title>
    <link href="/2020/05/07/LeetCode-226-Invert-Binary-Tree/"/>
    <url>/2020/05/07/LeetCode-226-Invert-Binary-Tree/</url>
    
    <content type="html"><![CDATA[<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p>题目链接：<a href="https://leetcode.com/problems/invert-binary-tree/description/">LeetCode 226.Invert Binary Tree</a></p><span id="more"></span><ul><li><p>递归逆转左右子树即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-built_in">swap</span>(root-&gt;left, root-&gt;right);<br>        root-&gt;left = <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        root-&gt;right = <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>Easy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 543. Diameter of Binary Tree</title>
    <link href="/2020/05/06/LeetCode-543-Diameter-of-Binary-Tree/"/>
    <url>/2020/05/06/LeetCode-543-Diameter-of-Binary-Tree/</url>
    
    <content type="html"><![CDATA[<h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><p>题目链接<a href="https://leetcode.com/problems/diameter-of-binary-tree/">LeetCode 543. Diameter of Binary Tree</a></p><span id="more"></span><blockquote><p>题目中定义二叉树直径为二叉树中任意两个节点间的最长距离</p></blockquote><ul><li><p>从底到上（避免子树高度的重复计算）依次计算通过每个子树跟节点p的最长路径，即$p.length&#x3D;max(height(p.left), height(p.right))+1$ 取所有p最大值即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!u) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">dfs</span>(u-&gt;left);<br>        <span class="hljs-type">int</span> r = <span class="hljs-built_in">dfs</span>(u-&gt;right);<br>        res = <span class="hljs-built_in">max</span>(res, l + r);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(l, r) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>Easy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 110. Balanced Binary Tree</title>
    <link href="/2020/05/06/LeetCode-110-Balanced-Binary-Tree/"/>
    <url>/2020/05/06/LeetCode-110-Balanced-Binary-Tree/</url>
    
    <content type="html"><![CDATA[<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>题目链接<a href="https://leetcode.com/problems/balanced-binary-tree/description/">LeetCode 110. Balanced Binary Tree</a></p><span id="more"></span><ul><li><p>自底向上遍历二叉树，用额外的变量res储存结果，遍历完成后（每个 节点遍历一次）返回结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">bool</span> res = <span class="hljs-literal">true</span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(left-right) &gt; <span class="hljs-number">1</span>)<br>            res = <span class="hljs-literal">false</span>;<br>            <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>Easy</tag>
      
      <tag>平衡树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 104. Maximum Depth of Binary Tree</title>
    <link href="/2020/05/05/LeetCode-104-Maximum-Depth-of-Binary-Tree/"/>
    <url>/2020/05/05/LeetCode-104-Maximum-Depth-of-Binary-Tree/</url>
    
    <content type="html"><![CDATA[<h2 id="树的最大高度"><a href="#树的最大高度" class="headerlink" title="树的最大高度"></a>树的最大高度</h2><p>题目链接 <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/">LeetCode 104. Maximum Depth of Binary Tree</a></p><span id="more"></span><blockquote><p>注意：本题的根节点深度定义为1</p></blockquote><ul><li><p>分治，代码简洁易懂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>DFS深度优先搜索</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> depth;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* u, <span class="hljs-type">int</span> cur_depth)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!u) <span class="hljs-keyword">return</span>;<br>        depth = <span class="hljs-built_in">max</span>(depth, cur_depth);<br>        <span class="hljs-keyword">if</span>(u-&gt;left) <span class="hljs-built_in">dfs</span>(u-&gt;left, cur_depth+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(u-&gt;right) <span class="hljs-built_in">dfs</span>(u-&gt;right, cur_depth+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用栈代替尾递归的DFS算法，用栈保存根到子节点的路径，栈内元素最大数量即为树的高度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> depth;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">while</span>(root) &#123;<br>            st.<span class="hljs-built_in">push</span>(root);<br>            root = root-&gt;left;<br>        &#125;<br>        depth = st.<span class="hljs-built_in">size</span>();<br>        TreeNode* last = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* t = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(t-&gt;right &amp;&amp; t-&gt;right != last) &#123;<br>                TreeNode* p = t-&gt;right;<br>                <span class="hljs-keyword">while</span>(p) &#123;<br>                    st.<span class="hljs-built_in">push</span>(p);<br>                    p = p-&gt;left;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                last = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            depth = <span class="hljs-built_in">max</span>(depth, (<span class="hljs-type">int</span>)st.<span class="hljs-built_in">size</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>BFS广度优先搜索，使用两个队列模拟层数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        deque&lt;TreeNode*&gt; q;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        q.<span class="hljs-built_in">push_back</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            deque&lt;TreeNode*&gt; t;<br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>                TreeNode* p = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop_front</span>();<br>                <span class="hljs-keyword">if</span>(p-&gt;left) t.<span class="hljs-built_in">push_back</span>(p-&gt;left);<br>                <span class="hljs-keyword">if</span>(p-&gt;right) t.<span class="hljs-built_in">push_back</span>(p-&gt;right);<br>            &#125;<br>            q = t;<br>            depth++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>递归</tag>
      
      <tag>Easy</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
